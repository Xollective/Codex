using System.Collections.Immutable;
using System.Text.Json.Serialization;
using Codex.Utilities.Serialization;

namespace Codex.ObjectModel
{
    public interface IStoredBoundSourceFile
    {
        IReadOnlyList<string> SourceFileContentLines { get; }

        IReadOnlyList<ICodeSymbol> References { get; }

        IReadOnlyList<ReadOnlyMemory<byte>> SemanticData { get; }

        IBoundSourceFile BoundSourceFile { get; }

        IReferenceListModel CompressedReferences { get; }

        IClassificationListModel CompressedClassifications { get; }
    }

    public interface INewBoundSourceFile
    {
        IProjectFileScopeEntity FileInfo { get; }

        ISourceFileBase SourceFile { get; }

    }

    /// <summary>
    /// Represents a source file with associated semantic bindings
    /// </summary>
    public partial interface IBoundSourceFile : IBoundSourceInfo, IBoundSourceScope
    {
        /// <summary>
        /// The source file
        /// </summary>
        ISourceFile SourceFile { get; }

        /// <summary>
        /// Gets the commit referencing the file.
        /// </summary>
        ICommit Commit { get; }

        /// <summary>
        /// The lines in the source file
        /// </summary>
        //[Include(ObjectStage.Analysis)]
        //IReadOnlyList<string> SourceFileContentLines { get; }
    }

    [GeneratorExclude]
    public interface IBoundSourceScope
    {
        [JsonIgnore]
        string ProjectId { get; }

        [JsonIgnore]
        string ProjectRelativePath { get; }

        [JsonIgnore]
        string RepoRelativePath { get; }

        [JsonIgnore]
        string RepositoryName { get; }

        [JsonIgnore]
        string Language { get; }

        [JsonIgnore]
        BoundSourceFlags Flags { get; }
    }

    public interface IBoundSourceInfo
    {
        /// <summary>
        /// The number of references in the file
        /// </summary>
        [CoerceGet(typeof(int?))]
        int ReferenceCount { get; }

        /// <summary>
        /// The number of definitions in the file
        /// </summary>
        [CoerceGet(typeof(int?))]
        int DefinitionCount { get; }

        /// <summary>
        /// References for the document. Sorted. May overlap.
        /// </summary>
        [ReadOnlyList]
        [Include(ObjectStage.Analysis)]
        [Exclude(ObjectStage.OptimizedStore)]
        IReadOnlyList<IReferenceSpan> References { get; }

        // TODO: Should this be just the symbol
        /// <summary>
        /// Definitions for the document. Sorted. No overlap?
        /// </summary>
        [ReadOnlyList]
        IReadOnlyList<IDefinitionSpan> Definitions { get; }

        /// <summary>
        /// Classifications for the document. Sorted by start index. No overlap.
        /// </summary>
        [ReadOnlyList]
        [Include(ObjectStage.Analysis)]
        [Exclude(ObjectStage.OptimizedStore)]
        IReadOnlyList<IClassificationSpan> Classifications { get; }

        ///// <summary>
        ///// Outlining regions for the document. May overlap.
        ///// </summary>
        //[ReadOnlyList]
        //[Exclude(ObjectStage.OptimizedStore)]
        //IReadOnlyList<IReferenceSpan> OutliningRegions { get; }
    }

    public enum BoundSourceFlags
    {
        None = 0,

        /// <summary>
        /// Remap local ids on classification spans
        /// </summary>
        RemapLocalIds = 1 << 0,

        DisableTextIndexing = 1 << 1,

        /// <summary>
        /// Indicates that bound source file only contains file info (not text content and semantic data)
        /// </summary>
        FileInfoOnly = 1 << 2,

        /// <summary>
        /// Indicates a special file generated by codex which should not be indexed for indices which support
        /// on demand generation of these files
        /// </summary>
        GeneratedMetadataFile = 1 << 3
    }

    /// <summary>
    /// Information about a source file as defined by the source control provider
    /// </summary>
    public interface ISourceControlFileInfo
    {
        /// <summary>
        /// Unique id for the source file content as defined by the source control provider (i.e. git SHA)
        /// </summary>
        [SearchBehavior(SearchBehavior.NormalizedKeyword)]
        string SourceControlContentId { get; }

        /// <summary>
        /// The number of lines in the file
        /// </summary>
        int Lines { get; }

        /// <summary>
        /// The size of the file in bytes
        /// </summary>
        int Size { get; }

        /// <summary>
        /// The encoding used for the file
        /// </summary>
        SourceEncodingInfo EncodingInfo { get; }
    }

    // TODO: Split off project file location info
    [ExcludeBase(typeof(ISourceControlFileInfo), ObjectStage.BlockIndex)]
    [ExcludeBase(typeof(IQualifierScopeEntity), ObjectStage.Analysis)]
    public interface ISourceFileInfo : IProjectFileScopeEntity, ISourceControlFileInfo, IQualifierScopeEntity
    {
        /// <summary>
        /// The language of the file
        /// </summary>
        string Language { get; }

        /// <summary>
        /// The web address of the file. This is NOT persisted. It is reconstructed from
        /// repository information and file information.
        /// </summary>
        [Include(ObjectStage.None)]
        string WebAddress { get; }

        /// <summary>
        /// The commit of the file. This is NOT necessarily persisted. It is reconstructed from
        /// repository information on query.
        /// </summary>
        [Include(ObjectStage.None)]
        string CommitId { get; }

        /// <summary>
        /// The web address for the raw content of the file. This is NOT persisted. It is reconstructed from
        /// repository information and file information.
        /// </summary>
        [Include(ObjectStage.None)]
        string DownloadAddress { get; }

        /// <summary>
        /// Extensible key value properties for the document.
        /// </summary>
        [Include(ObjectStage.Analysis)]
        IPropertyMap Properties { get; }
    }

    public interface ISourceFileBase
    {
        /// <summary>
        /// The information about the source file
        /// </summary>
        ISourceFileInfo Info { get; }

        /// <summary>
        /// Gets flags associated with the bound source file.
        /// </summary>
        BoundSourceFlags Flags { get; }

        /// <summary>
        /// Indicates that the file should be excluded from text search
        /// </summary>
        [SearchBehavior(SearchBehavior.Term)]
        bool ExcludeFromSearch { get; }
    }

    /// <summary>
    /// Defines text contents of a file and associated data
    /// </summary>
    public interface ISourceFile : ISourceFileBase
    {
        /// <summary>
        /// The content of the file
        /// </summary>
        [Include(ObjectStage.Analysis)]
        [CoerceGet]
        string Content { get; }

        [CoerceGet]
        [Include(ObjectStage.None)]
        TextSourceBase ContentSource { get; }
    }

    /// <summary>
    /// Defines text contents of a file and associated data
    /// </summary>
    public interface IChunkedSourceFile : ISourceFileBase
    {
        /// <summary>
        /// The content of the file
        /// </summary>
        IReadOnlyList<IChunkReference> Chunks { get; }
    }

    public interface IChunkReference
    {
        [SearchBehavior(SearchBehavior.Term)]
        int Id { get; }

        int StartLineNumber { get; }
    }

    public interface IOutliningRegion
    {
        /// <summary>
        /// Defines the region containing the header text of the outlining region
        /// </summary>
        ILineSpan Header { get; }

        /// <summary>
        /// Defines the region containing the collapsible content region of the outlining region
        /// </summary>
        ILineSpan Content { get; }
    }

    public interface IDefinitionSpan : ISpan, ISpanWithSymbol
    {
        /// <summary>
        /// The definition symbol referred to by the span
        /// </summary>
        IDefinitionSymbol Definition { get; }

        Extent FullSpan { get; }

        /// <summary>
        /// Gets the definitions for parameters
        /// </summary>
        [ReadOnlyList]
        IReadOnlyList<IParameterDefinitionSpan> Parameters { get; }

        IReferenceSymbol ISpanWithSymbol.Symbol => Definition;
    }

    [GeneratorExclude]
    public interface ISpanWithSymbol : ISpan
    { 
        IReferenceSymbol Symbol { get; }
    }

    /// <summary>
    /// A specialized definition span referring to a parameter of a method/property
    /// </summary>
    public interface IParameterDefinitionSpan : ILineSpan
    {
        // TODO: This is in theory implied from the ordering in IDefinitionSpan.Parameters. So no need
        // to serialize if its the same as the implied value
        /// <summary>
        /// The index of the parameter in the list of parameters for the method
        /// </summary>
        int ParameterIndex { get; }

        /// <summary>
        /// The name of the parameter
        /// </summary>
        string Name { get; }
    }

    public interface IReferenceSpan : ISymbolSpan, ISpanWithSymbol
    {
        /// <summary>
        /// Gets the symbol id of the definition which provides this reference 
        /// (i.e. method definition for interface implementation)
        /// </summary>
        SymbolId RelatedDefinition { get; }

        /// <summary>
        /// The reference symbol referred to by the span
        /// </summary>
        IReferenceSymbol Reference { get; }

        /// <summary>
        /// The container symbol of the reference span if available
        /// </summary>
        [UseInterface]
        IDisplayCodeSymbol ContainerSymbol { get; }

        /// <summary>
        /// Indicates the corresponding reference span is implicitly declared and therefore this should not be
        /// used for find all references search
        /// </summary>
        [SearchBehavior(SearchBehavior.Term)]
        bool IsImplicitlyDeclared { get; }

        /// <summary>
        /// Gets the references to parameters
        /// </summary>
        [ReadOnlyList]
        IReadOnlyList<IParameterReferenceSpan> Parameters { get; }

        IReferenceSymbol ISpanWithSymbol.Symbol => Reference;
    }

    /// <summary>
    /// A specialized reference span referring to a parameter to a method/property
    /// </summary>
    public interface IParameterReferenceSpan : ISymbolSpan
    {
        /// <summary>
        /// The index of the parameter in the list of parameters for the method
        /// </summary>
        [SearchBehavior(SearchBehavior.Term)]
        int ParameterIndex { get; }
    }

    public record struct LineSpan<T>(int LineNumber, int Start, int Offset, int Length, T Value, Extent FullLineExtent)
    {
        public Extent Intersect => new Extent(Start, Length);

        public Extent LineRelativeExtent => new Extent(Offset, Length);

        public bool CoversEntireLine => FullLineExtent.Length == Length;
    }

    /// <summary>
    /// Defines a classified span of text
    /// </summary>
    public interface IClassificationSpan : ISpan
    {
        /// <summary>
        /// The default classification color for the span. This is used for
        /// contexts where a mapping from classification id to color is not
        /// available.
        /// </summary>
        int DefaultClassificationColor { get; }

        /// <summary>
        /// The classification identifier for the span
        /// </summary>
        StringEnum<ClassificationName> Classification { get; }

        // TODO: Should locals be moved from here?
        /// <summary>
        /// The identifier to the local group of spans which refer to the same common symbol
        /// </summary>
        int LocalGroupId { get; }

        // TODO: Should locals be moved from here?
        /// <summary>
        /// The symbol depth of the local represented by <see cref="LocalGroupId"/>.
        /// </summary>
        int SymbolDepth { get; }
    }

    public interface ISharedReferenceInfoSpan : ISymbolSpan
    {
        ISharedReferenceInfo Info { get; }
    }

    public interface ISymbolSpan : ITextLineSpan
    {
    }

    public interface ITextLineSpan : ILineSpan
    {
        /// <summary>
        /// The line text
        /// </summary>
        [Include(ObjectStage.Index)]
        CharString LineSpanText { get; }
    }

    public interface ILineSpan : ISpan
    {
        /// <summary>
        /// The 0-based index of the line containing the span
        /// </summary>
        [Include(ObjectStage.None)]
        [CoerceGet(typeof(int?))]
        int LineIndex { get; }

        /// <summary>
        /// The 1-based line number of the line containing the span
        /// </summary>
        [CoerceGet(typeof(int?))]
        int LineNumber { get; }

        /// <summary>
        /// The character position where the span starts in the line text
        /// </summary>
        int LineSpanStart { get; }

        /// <summary>
        /// If positive, the offset of the line span from the beginning of the line
        /// If negative, the offset of the linespan from the end of the next line
        /// </summary>
        int LineOffset { get; }
    }

    public static class SpanExtensions
    {
        public static int LineSpanEnd(this ILineSpan lineSpan)
        {
            return lineSpan.LineSpanStart + lineSpan.Length;
        }

        public static CharString GetSegment(this ITextLineSpan lineSpan)
        {
            return lineSpan.LineSpanText.Substring(lineSpan.LineSpanStart, lineSpan.Length);
        }

        public static int End(this ISpan lineSpan)
        {
            return lineSpan.Start + lineSpan.Length;
        }

        public static bool SpanEquals(this ISpan span, ISpan otherSpan)
        {
            if (span == null)
            {
                return false;
            }

            return span.Start == otherSpan.Start && span.Length == otherSpan.Length;
        }

        public static bool Contains(this ISpan span, ISpan otherSpan)
        {
            if (span == null || otherSpan == null)
            {
                return false;
            }

            return otherSpan.Start >= span.Start && otherSpan.End() <= span.End();
        }

        public static Extent AsExtent(this ISpan span)
        {
            return new Extent(span.Start, span.Length);
        }
    }

    public interface ISpan
    {
        /// <summary>
        /// The absolute character offset of the span within the document
        /// </summary>
        int Start { get; }

        /// <summary>
        /// The length of the span
        /// </summary>
        int Length { get; }
    }
}
